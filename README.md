# Physical Verification Workshop using SKY130 PDK
![Logo](https://user-images.githubusercontent.com/109404741/195650208-c2e6f35d-d10e-4a3f-80da-99fa484b6b7a.PNG)
This is a 5 day workshop conducted by VLSI System Design (VSD) from 10th October 2022 to 14th October 2022. This workshop mainly focuses on
the different steps that are required for a physical design verification which includes steps like DRC and LVS. Below is a brief documentation
of the full workshop.

# Day 1 - Introduction to Skywater Sky130 and Open-source EDA tools
## Skywater PDK
  The SkyWater Open Source PDK is a collaboration between Google and SkyWater Technology Foundry to provide a fully open source Process Design Kit and related resources, which can be used to create manufacturable designs at SkyWaterâ€™s facility.
The skywater PDK documentation can be found at the blink below :
https://skywater-pdk.readthedocs.io/en/main/

## Open-source EDA tools

Tools currently supported by open_pdks:
- Magic
- Klayout
- Openlane
- Xschem
- Netgen
- Ngspice
- IVerilog
- qflow
- IRSIM
- xcircuit

The following steps can be followed to instal SKY130 PDKs :

```
git clone https://github.com/RTimothyEdwards/open_pdks
cd open_pdks
configure --enable-sky130-pdk
make
sudo make install
```

The SkyWater PDKs are placed under the directory /usr/share/pdk/sky130A/. There are 2 subdirectories under this folder.One is the libs.tech, which contains all subdirectories for the open source tool setups like xschem (for schematic), Magic(for layout) and netgen(for LVS). The second one is the libs.ref, which contains the reference libraries in various formats.

# Physical verification and Design flow
In functional verification of a circuit we check wether the circuit is giving desired output or not. 
In case of physical verification we check for valid Layout mask (stencils used by manufacturers) and also to match the layout with the actual circuit that we have initially described.

There are two main things in Physical design verification:
1. Design Rule Check (DRC)
2. Layout Vs. Schematic (LVS)

![DRC and LVS](https://user-images.githubusercontent.com/109404741/195654231-124b2417-49aa-473c-89b5-e69b327bb1c0.PNG)

At first we make the schematic using any schematic tool like xschem, eSim etc and then generate the Netlist of the circuit. Then we create a layout of the circuit
using Layout tools like Magic, Klayout. initially, the layout will have some design errors which are discussed later in the documentation. This is where DRC comes
and it helps us to look for error in the design and correct them to meet foundry standards. Then we do an extraction which converts the layout to a netlist file.
Next we compare the netlist generated by the Layout tool and the Schematic tool to compare and look for any mismatches. If there is no mismatch then the layout
fully conforms to the actual design of the circuit.

# Day 1 - Lab
Day 1 lab is all about checking the open-source tools installed in the system and creating a simple inverter circuit from schematic to LVS.

1. To open Magic Layout tool we run the command ```magic``` in the terminal. This brings up a layout window and a console window that is a stock tcl interpreter used to run commands for layout and actions. There are other ways of running Magic tool which uses hardware acceleration. The following command ```magic -d XR``` will run
Magic layout using hardware acceleration. For running Magic using Open GL we can type ```magic -d OGL```.

2. To open Xschem schematic tool we run the command ```xschem``` in the terminal. This will open the schematic window where we can draw out circuit and also generate
Netlist and simulate our circuit.

3. To run Netgen(for LVS) we run the command ```netgen``` in the terminal. It is completely command driven and has no graphics interface. Its console window is a stock tcl interpreter like magic as well. We can get the tcl interpreter in the terminal itself instead of the seperate console window by using the option ```netgen -noconsole```. To run netgen in batch mode, we use the command ```netgen -batch source filename.tcl```. Netgen also provides a GUI window written in python that can be accessed using ```usr/local/lib/netgen/pyhton/lvs_manager.py```, though this interface hides many useful options that cannot be accessed with just this window itself.

## Starting a new project

1. In order to set a working environment for a project we should make a folder with the name of the project and inside it there should be three folder named:

    -mag  (for magic)
    
    -xschem  (for Xschem tool)
    
    -netgen  (for running LVS)
   
![mag_xschem_netgen_folders](https://user-images.githubusercontent.com/109404741/195658089-defc99c3-6afc-4c6d-8268-8ee3a6c723ff.PNG)

Next, we must set up each directory for its respective tool to run properly with the SkyWater PDKs. This can be done by creating a symbolic link between the just initialised subdirectories and the SKY130 submodules created with the open_pdks installer. This is done using ```ln -s /file_path``` in the desired subdirectory, and is shown below. As we will run ngspice simulations using xschem, so we setup ngspice under the xschem subdirectory itself and similarly netgen in the netgen folder
and magic in the magic folder.
![folder setups](https://user-images.githubusercontent.com/109404741/195659657-23332a62-a2e1-48f1-9b15-7a8993c8657f.PNG)
## Designing an inverter

First we have to make the schematic of the inverter circuit so, we go to the xschem folder using ```cd ../xschem``` and then run ```xschem``` which will open the
Xschem tool window.

![xschem window](https://user-images.githubusercontent.com/109404741/195660402-df0c6d1a-e969-4682-abf2-b95b57cbdf3c.PNG)

For creating a new design we go to file and click on new schematic. A black window will appear where we can build our circuit schematic. To insert devices like
I/O pins, transistors (nfets and pfets) we use the "Insert" key on the keyboard. From the window we can select the device. Below is the schematic of the inverter
drawn in the Xschem tool.
![inverter layout](https://user-images.githubusercontent.com/109404741/195662912-3d0c1a6b-212e-4387-80fa-65abbd0841dd.PNG)

To configure the properties of the devices, we can select them by clicking on them and bringing up the parameter window with the Q key. We change the length in the parameter window to 0.18 as the default value of 0.15 is restricted to sram devices only. We can set the number of fingers to 3, and the width of each finger to 1.5. As we have 3 fingers however, the total width in the parameter window must be set to 3 times of the finger width, which is 4.5.

To functionally validate we have to simulate our circuit so, we have to create a testbench in Xschem which can simulate the circuit. The following image is the testbench setup.

![testbench](https://user-images.githubusercontent.com/109404741/195663512-07c30860-82b6-4a2f-b683-890461956abd.PNG)

We set the supply voltage to 1.8V as vdd and for the vss we use the gnd. For input voltage we use a piece wise linear voltage source. In the parametre box we write
the value of the input voltage source as ```value = PWL(0 0 20n 0 900n 1.8)```. The simulation was of transient type and the simulation duration was set to 1us. The following is the simulation result which shows the input and the output voltage:

![inverter output](https://user-images.githubusercontent.com/109404741/195664859-ee066c9e-f860-470b-8496-f6edbb6d153e.PNG)
After this the next step is to create a layout for this inverter circuit. So, we move to the mag directory ```cd ../mag``` and then run ```magic``` in the terminal. This will open the magic tool window. Now we have to open the spice netlist of the inverter circuit. Initially all the ports and transistors will be in a random manner as shown below:
![layout_random_inv](https://user-images.githubusercontent.com/109404741/195665523-43d5d5df-f358-4d3c-b518-c3612f209d69.PNG)

Next, we must set some parameters that are only adjustable in the layout which will make it more convenient to wire the whole layout up. First, we set the "Top guard ring via coverage" to 100. This will put a local interconnect to metal1 via ta the top of the guard ring. Next, for "Source via coverage" put +40 and for "Drain via coverage" put -40. This will split the source drain contacts, making it easy to connect them with a wire. For the nfet, we set the "Bottom guard ring via coverage" to 100, while the source and drain via coverages are set to +40 and -40, respectively, like the pfet. In the above picture it has the I/O pins and the two fets (nfet and pfet). We have to arrange them to draw the inverter circuit and connect them using the Metal 1 layer as shown below :

![layout inv](https://user-images.githubusercontent.com/109404741/195666266-96f8a80c-c29b-43d8-b03e-ca8b2ed6d612.PNG)

After saving and autowriting the layout we have to do the extration. This will create an intermediate file with .ext extention. Then we will convert this file to a SPICE netlist which will be next used by netgen for running LVS check of the inverter circuit. For this we write the following commands in the command window:

```extract do local```  -> This command ensures that magic writes all results to the local directory

```extract all```       -> This command does the actual extraction.

```ext2spice```         -> This command converts the .ext file to the SPICE netlist

Now we can run LVS by entering the netgen subdirectory and using the command ```netgen -batch lvs "../mag/inverter.spice inverter" "../xschem/inverter.spice inverter"```. We should always write the layout spice netlist file name first and then the schematic spice netlist second. The result after running LVS is as follows:

![lvs result](https://user-images.githubusercontent.com/109404741/195669232-74f4525b-10b3-448a-9fb7-00a0f66fb036.PNG)

From the above picture we can see the result after running LVS. At the end it says the the two netlists match. So, we can confirm that our layout perfectly complies
with the Schematic.

# Day 2 -  Design Rule Checks and Layout Vs. Simulation
## Data formats 
For standardisation in order to describe ICs, standard file formats are required. These are mainly data describing the layout and some metadata which consists of labels, cells etc.
Some common file formats are:
-  Caltech Intermediate form (.cif)
-  GDSII stream format
-  Open Artwork System Interchange Standard (OASIS)
-  
The GDSII format is now the industry standard accross foundries for representing IC layouts.

### Extraction Styles in Magic
  Since we need to generate SPICE netlist from Magic tool we have to extract. Magic provides several extraction options. They are listed below:
  
ext2spice lvs
ext2spice cthresh value
ext2spice scale on|off
ext2spice hierarchy on|off
ext2spice subcircuit top on|off
ext2spice global on|off
ext2spicemerge on|off

### GDS Reading and Writing in Magic
For read and GDS file we run the command ```gds read file_name``` in the command window.
Some important read options for gds files in magic are listed below.

```
gds readonly true|false  //Allows ceratin cells to be read-only, preventing magic from changing their gds descriptions in the final output gds file
gds flatglob expression  //Flattens cells in question to be merged up into the hierarchy above them, preventing unnecessary heierarchy in the layout
gds flatten true
gds noduplicates true    //Tells magic to ignore cell definitions in gds files that it already has in memory
```

For writing gds files we can use the command ```gds write file_name```.

Some of its options are listed below.

```
gds library true      //Used to create gds library files with subcells with no concept of a top level layout
gds addendum true     //Ignores read-only cell definitions when it generates an output
gds merge true|false  //Turns rectangles and triangles present in the design into merged polygons for easier viewing
```
## DRC Rules
Magic layout has three DRC styles they are FULL, FAST and ROUTING.

The following commands are used for setting the DRC styles:

1. ```drc(full)``` - complete checks (slow)
2. ```drc(fast)``` - typical checks (fast)
3. ```drc(routing)``` - metal checks (fastest)

The two basic DRC rule checking methods in Magic are,

1. Edge-based rules (spacing, width, surround, extend)
2. Boolean geometry rules (AND, XOR, GROW, SQUARES, etc.)

## LVS Setup for Netgen
Netgen is the tool that is used for running LVS on the two netlists generarted by the Schematic tool and the layout tool. It doesnot perform any functional validation just checks for netlist mismatch.

## XOR Verification

This is also a type of verification and is mainly used for mask revisions. Two layouts are compared using XOR test. When two layouts have the same components at a particular region it will show nothing in the result file. So, the result file of the XOR test only shows the portions that are different or not present in either of the two layouts. Below shows an example of how XOR test works.

![XOR test example](https://user-images.githubusercontent.com/109404741/195673847-f940127d-d560-47e1-aef3-8f23222096fb.PNG)

To run XOR test of two layouts the following commands are used:
```
load layout1_name
flatten destination_name
load layout2_name
xor destination_name
```
## Reading GDS
 The following command was used to read the GDS files of the standard sky130 PDK library cells:
 
 ![Command for reading gds library of sky130 pdk](https://user-images.githubusercontent.com/109404741/195674695-df399f6b-a156-45be-868e-9bdc514fa769.PNG)
This will load all the standard GDS files and can be accessed using Magic tool by going to options and then cell manager and selecting any one of the cells for viewing the GDS file.

![opening and2_1 cell from options-cell manager](https://user-images.githubusercontent.com/109404741/195675168-da047be9-4e84-4e64-9419-42af13a6a88a.PNG)

For the workshop Laboratory we chose the AND2_1 cell.

## Ports and Port Indexes

To know about a port in the layout we can use the Magic command box. To do this select a port and type the command ```port index```.

![for getting the port index](https://user-images.githubusercontent.com/109404741/195685632-8684c06b-adfd-4c34-afa4-600c77bebe3f.PNG)

The command `port first` to find the index of the first port. we can then inquire about the port with the commands below.

```
port 1 name
port 1 class
port 1 use
```
![For port names](https://user-images.githubusercontent.com/109404741/195686472-8b26fe0c-6a75-4629-8982-d96543f86eec.PNG)

## Basic R-C Extraction
Magic gives us a way to do the parasitic resistance and and capacitances with the use of some commands. This also lets us to generate a netlist file with the parasitic resistances and camacitances. The below image shows the command for parasitic capacitances extractions and create a netlist with it:

![Parasitic extraction1](https://user-images.githubusercontent.com/109404741/195688681-73b139aa-466c-491f-922a-b72f5a816f6f.PNG)

The command ```ext2spice cthresh 0``` is used to extract the list of parasitic  capacitances with values greater than 0fF (femto Farad). The next command ```ext2spice``` generates the netlist with the parasitic capacitances. The below image shows the netlist with parasitic capacitances:

![and2_1 netlist with parasitic caps](https://user-images.githubusercontent.com/109404741/195689269-69a8d963-9ebb-4c44-8fd9-3826cc4e93cd.PNG)
 As we can see the above netlist consists of all the 21 parasitic capacitances in the standard AND2_1 cell.
 
 If we want to consider only the parasitic capacitances above a certain value then the following command must be used ```ext2spice c thresh 0.01```.
 This command will only consider the netlist with capacitances greater than 0.01 fF. THe below image shows the netlist with capacitances above 0.01 fF:
 ![cthresh 001 netlist and2_1](https://user-images.githubusercontent.com/109404741/195689768-54f4b755-9bc2-4e4c-b623-d20c3c7ab682.PNG)

So, in the netlist the number of parasitic capacitances has decreased to 17 from 21.

Similarly, a command exists for generating the parasitic resistances. The command ```extresist tolerance 10``` followed by the command ```ext2spice``` will generate a netlist with the parasitic resistances as follow:

![resistance netlist and2_1](https://user-images.githubusercontent.com/109404741/195690927-62f9da8f-b69c-41c1-9450-1e0e53e65283.PNG)

We can also generate a netlist with full R-C extraction by using the following commands:

```ext2spice lvs
   ext2spice cthresh 0
   extresist tolerance 10
   ext2spice extresist on
   ext2spice
```
The corresponding netlist with full R-C extraction is shown below:
![RC extracted netlist](https://user-images.githubusercontent.com/109404741/195691662-86cac6f9-d5d3-4b23-bf3b-57113e83be06.PNG)

## Setup for DRC
To set up standard DRC, we can use the following commands to call a python script.
![Batch DRC for and2_1](https://user-images.githubusercontent.com/109404741/195692054-047eb6f6-ca8f-48eb-819d-6b00ee02762d.PNG)

This python script will generate a .txt file which consists of all the DRC errors present in the AND2_1 cell as shown below:
![DRC errors and2_1](https://user-images.githubusercontent.com/109404741/195692207-75c734b6-2db3-439f-a0bf-c56729b3e990.PNG)

One thing to note here is that while running the DRC checker in the magic command box by using the command ```drc check``` followed by the command ```drc why``` showed lesser number of errors because the default drc style in the Magic tool is FAST while the DRC style used by the python script is FULL. However, we can change the DRC style in Magic tool by using the command ```drc style drc(full)```.

## Setup for LVS
To run LVS on Netgen we have to first create a seperate folder named netgen by using ```mkdir netgen``` and then move in to the netgen folder and setup the environment for LVS. The following image shows the copy comand ```cp ..``` used for copying the the netgen setup file from sky130 PDK. This also copies the netlist of the AND2_1 cell in the folder which we will use to compare with the netlist generated by the Magic tool without R-C extraction.

![setting up netgen](https://user-images.githubusercontent.com/109404741/195693457-631fd30d-d5e8-481b-a1c0-0049ca3a5fa2.PNG)

For running the netgen in batch mode the following command is used:

![running netgen in batch](https://user-images.githubusercontent.com/109404741/195694025-5b495554-415f-413b-b259-b6555adf3441.PNG)
 The following the shows the result after running netgen on the netlists:
 ![lvs result](https://user-images.githubusercontent.com/109404741/195694144-1dc5e3a3-a3bb-484e-a26a-9bfdb2eeda38.PNG)

So, the netlists match uniquely.

## Setup for XOR verification
For running XOR test we create a locally saved AND2_1 layout file in the mag folder so that is becomes editable and we can change the layout a little bit to run the XOR test on this changed layout and the default AND2_1 layout from thr skywater library. The following change was done in the layout: 

![and2_1 deleted Layer for XOR test](https://user-images.githubusercontent.com/109404741/195694719-3a8db753-17b1-45fc-884d-3c7655c4cee0.PNG)
In the above modified layout a small Local interconnect was erased by selecting the area and using the command ```erase li```. So, we can expect that running a XOR test with this layout and the actual unmodified default layout will give a result layout which will have the deleted Local interconnect layout. The following commands were used to run the XOR test:

![performing XOR test](https://user-images.githubusercontent.com/109404741/195695063-62b52bd7-9738-46a3-9449-503697633e09.PNG)

The following is the result of the XOR test:
![XOR test result](https://user-images.githubusercontent.com/109404741/195695142-bf18166d-1a0a-4bb2-ae89-f3263ac2bb55.PNG)
 As expected the deleted Local interconnect showed up in the result file.
 
 Another XOR test was performed by slightly shifting the original layout to the right and the following test result was observed:
 ![xor test 2](https://user-images.githubusercontent.com/109404741/195695344-ee537777-a24e-432f-a45f-d2a933d24e1c.PNG)
So, this only shows the unoverlapped portions of the layouts.

# Day 3 - Design Rule Checking (DRC)
Silicon manufacturing processes have some tolerance limit which are defined by certain set of design rules that needs to be taken care of by the Physical design engineers. To assist this process layout tools have DRC programs running in the background which marks the regions of error with white dots.

The Skywater process has its own design rules which can be read from this link : https://skywater-pdk.readthedocs.io/en/latest/rules.html

### Back-end Metal Layer Rules

**1. Width Rule**
* Gives the minimum width of a layer.
* Not adhering to this can cause spot defects to be larger than the width of the layer itself, causing open circuits in wires.
* Minimum width for implants are given based on angle of implant and crystalline structure of the silicon. Implants in layer with very small widths may not act like they are supposed to.
* Feature size of a process gives the minimum width of a transistor (or its polysilicon layer)

**2. Spacing Rule**
* Gives the minimum spacing between two layers.
* Not adhering to spacing rales may cause material defects creating shorts between layers.
* Has several complications based on optical effects of the mask.

**3. Wide-Spacing Rule**
* If a wire or piece of layout is wider than a given distance, then other wires of any width must be kept away from it by an additional amount of space.

**4. Notch Rule**
* Similar to the spacing rule (generally the same in most processes).
* Gives the minimum space between two forks of the same piece of layer.

**5. Minimum and Maximum Area Rules**
* Gives the minimum and maximum areas for a metal layer.
* Prevents delamination issues in the metal surface.
* Implants only have minimum area rules, due to concerns same as that of the width rule.

**6. Minimum Hole Area Rule**
* Gives the minimum are a hole in a metal layer must be.
* Small holes in a metal layer make it more likely that oxide grown over the hole may not completely fill it.

**7. Contact Cut Rules**
* A Via is the contact cuts made between metal layers to connect them using other metals.
* As the holes connect layers from above and below, their positioning is critical.
* Contact cut rules ensure masks can be positioned correctly.
* Contact cuts must be surrounded by a minimum amount of metal around them.
* Magic displays arrays of contact cuts for the same layer to layer connect as a single large contact cut (via) for design simplicity.

### Local Interconnect Rules

Most foundry processes go directly from polysilicon layers to aluminium (metal1). SkyWater uses local interconnect layers as routing layers between polysilicon and metal layers. Rules for this layer are based on physical properties of the material, mainly its resistance per square.

The aspect ratio of any uncontacted local interconnect layer should generally be greater than 1:10. Generally, local interconnect should only be used to connect nearby layers and not for longer routing.

### Front-end Rules

These are rules that are device specific, and generally do not need to be handled with unless designing standard cells or designing special layouts that don't use standard cells. In Magic, the user can use the parameterized device generator which will automatically generate a device that satisfies and adheres to these device specific rules.

MOSFET transistors have minimum gate width and length rules to account for the alignment between the diffusion and polysilicon masks. There are also field poly to diffusion spacing rules to prevent accidental transistors from forming. The gate poly to diffusion contact rule specifies how close the drain and source contacts can get to the gate.

### Wells, Taps and Net Rules

A tap is a region of diffusion that is doped with the opposite implant type of the transistor source or drain. Taps sit inside wells, and are of the same doping type as the well, making them electrically connected. The tap forms a connection to the well to set the bias voltage specifically, so that the p-n junction formed between the transistor and its surroundings is firmly reverse biased, keeping the transistor from leaking more than an acceptable amount of current.

Standard cell taps follow one set of rules which keeps p and n type diffusions separated from them by a minimum amount of distance, known as the diffusion to tap spacing rule. There are also butted taps, which keep the p and n taps sharing the same diffusion region, and have extra rules associated with them.

Same-net spacing rules pertain to wells, most often applied if two n-well regions on different nets must have extra spacing between them, more than the minimum specified spacing between any 2 n wells.

### Deeps N-Well and High Voltage Rules

Deep n-wells are used to decrease noise coupling effects in p substrates from nmos devices. These wells have a number of design rules associated with them. Deep n-wells have large minimum width requirements, as well as very large minimum spacing requirements between 2 distinct deep n-wells.. They must also have a fence of n-well around it that overlaps by a minimum amount on both the inside and outside.

High voltage implants in transistors allow the n-well under the p type transistor, as well as the source and drain of both n and p type transistors to be tolerant of higher voltages. High voltage transistors also require thicker gate oxide layers to prevent gate punch through at higher voltages. Since the high voltage layer directly affects the transistor, it comes with a number of rules. First, the diffusion layers have greater space and width requirements. N-wells have greater spacing requirements, both to themselves and low voltage wells, and transistor gates have to be both wider and longer.

### Device Rules

Resistors are very complicated in the SkyWater process, and have many associated design rules. Resistors can be made with diffusion layers, polysilicon layers or p-well regions deep inside n-wells. Certain polysilicon resistors have specific design rules, such as the contact cuts must be rectangular and not square. Though, generally most designers will use the pdk design generator in magic to create resistor designs that adhere to design rules.

Capacitors come in 4 distinct types in the SkyWater process; Varactors, MOScap, Vertical Parallel Plate (VPP), Metal-insulator-Metal (MiM). Varactors share similar DRC rules to MOSFETs, but with some different requirements to width, length, gate extension and contact distance from the gate. MOScaps follow the same DRC rules as MOSFETs. VPPs are also called Metal-Oxide-Metal (MOM) capacitors, and just follow the DRC rules for metal layers such as width and spacing. MiM capacitors boast much higher capacitance per unit area values than regular MOM capacitors, and have minimum and maximum width rules for the inside capacitor plate, as well as requirements for the metal plate underneath to have a certain amount of surrounding material. MiM capacitors also have aspect ratio rules, and bottom and top layer rules, and are subject to antenna rules as well.

Diodes are formed by the p-n junction between the diffusion and well. These are usually unwanted parasitic devices since they are formed whenever you place down a transistor, n-well or deep n-well. When placing diodes, they follow similar DRC rules as those of diffusion, tap and well layers. They can also be used to overcome antenna rule violations.

Certain devices have reference layouts created by the foundry itself, and are guaranteed to be to DRC correct, as long a the designer follows spacing requirements between these and other devices. These devices are called fixed layout devices.

### Miscellaneous Rules and Latch-up, Antenna and Stress Rules

Some rules in the SkyWater process are not layer specific. Off grid rule specifies that all geometry in a design layout must have vertex coordinates that fall on a grid point in the manufacturing grid. Any non-manhattan shapes must have vertices that fall on grid points only. Angle limitation rules demand certain layers to have only manhattan geometry, while the others are limited to only 45 degree geometry. Seal rings have certain design rules of themselves, but magic presents DRC correct seal ring layouts that fit the dimensions of the chip automatically.

When a parasitic p-n junction becomes forward biased, it creates a condition called Latch-up. This can cause effectively pnp and npn transistors to form across the well, tap and substrate layers, thus shorting the entire chip and causing it to get stuck in this state till the power supply is removed. Thus, design rules for latch-up conditions specify a minimum distance between a tap connection and diffusion region anywhere on the design.

Antenna rules dictate how to avoid electrical manufacturing failures, and depend on chip layout at specific points during the manufacturing process. For example, large portions of routing material can build charge during the manufacturing process and then cause high voltage punch throughs in components nearby, such as transistor gates. Thus, antenna rules apply to any long strips of material with one end tied to a transistor gate and the other rule untied, or tied to another layer above it. One way to avoid antenna violations is to provide a path to ground through a parasitic p-n junction of diffusion, anywhere on the material that violates the rule.

Stress rules are related to metal delamination, and metal cracking and other damage caused by stress on the chip during wire bonding and sawing. To mitigate this we have slotting rules, which state that wide metal layers should be perforated with slots to keep any part of the metal from exceeding some maximum width. These slots should be in the direction of current flow.

### Density Rules

Metal route layers that are not flat can cause layers above them to not be deposited as flat surface either. Metal layers undergo a polishing step, though the existing metal before polishing must have a certain amount of flatness as well. Oxide layers are added between metal layers, that deposit in a snow coverage-like pattern. If there are large spaces 2 metal routes on the same layer, the oxide layer will have bumps, and subsequent layers created above them too. To overcome this, fill material is used between the gaps of the metal, to achieve a certain 'density' of material.

There are automated tools that can generate fill patterns in a layout to meet density requirements. Though in analog designs, fill patterns can create unwanted capacitances hat are difficult to analyse. There are certain conditions where 2 metal layers are just spaced apart enough that there isn't enough room between them to add fill material, yet there is enough space to cause bumps in the layers above.

### Recommended, Manufacturing and ERC Rules

Recommended rules are design rules that can be followed to make a design more robust, and improve yield. These include rules such as having more than one contact cut per via, and violating these will not cause the foundry to reject the design. Though, as recommended rules increase production yield, they are very handy for production designs.

When creating test designs however, the bare minimum rules that must be followed so that the foundry does not immediately reject your design are called Manufacturing rules. These are listed below.
- Width rules
- Spacing (notch) rules
- Minimum area rules
- Overlap (surround) rules
- Extension rules
- Angle and off-grid rules
- Density rules (acceptable, rarely)

Rule violations that persist in the final design require a waiver from the manufacturer, which is a statement that verifies that the customer holds full liability for any risks arising from such violations and not the foundry.

Electrical Rule Checks (ERC) are checks for a layout that is DRC correct but cause certain failure due to electrical problems. These are,
1. Electromigration (max. current density) - damage to metal wires for carrying too much current over a period of time
2. Overvoltage conditions - occur especially when high and low voltage circuit designs are combined.

#Day 3 Lab
## Width and spacing rules

For this lab a git clone link was given which contained all the exercises for the DRC. This is the link: https://github.com/RTimothyEdwards/vsd_drc_lab

Exercise_1.mag has a width and spacing error:

   ![DRC_exercise_1 layout](https://user-images.githubusercontent.com/109404741/195697921-d6f7ec9f-1027-4ceb-b1b3-ba33656f4960.PNG)

The first error is of a width as follows:

![1_DRC_report_width](https://user-images.githubusercontent.com/109404741/195698065-744d8e66-71de-44f6-a1be-201bb27256ea.PNG)

This error can be fixed by selecting the layer and using the command ```box grow e lenght_value``` and then filling the empty area with the metal 2 layer. This will fix the width error.
![fixed width](https://user-images.githubusercontent.com/109404741/195698536-a918e4ab-1dbf-42c4-b00d-46bdb066ba65.PNG)

The next error is a spacing error between two metal 1 layers:
![Metal_spacing DRC](https://user-images.githubusercontent.com/109404741/195698859-8e3c413a-4f22-4830-a072-a7c21aec39a8.PNG)

This error can be fixed by selecting one of the two layers and moving that layer away using the shift key with the num keys 4,6,8 for directions. The DRC error was fixed using this method.
![metal spacing error fixed](https://user-images.githubusercontent.com/109404741/195699063-b3e24135-550d-4be4-a2fb-159bcf33a774.PNG)

The next error is a wide spacing error:
![Wide spacing error fixed](https://user-images.githubusercontent.com/109404741/195699460-d0ecc748-d355-4b39-8478-3bd74346fd7a.PNG)
This is a simple fix, and can be done by moving either of the boxes by a distance of 0.4um away, as shown below.
![Wide spacing error fixed](https://user-images.githubusercontent.com/109404741/195699656-d8e0edc7-1fa6-40df-83be-d34eda583265.PNG)

The next error is due to the violation of the notch rule as shown below:
![notch error](https://user-images.githubusercontent.com/109404741/195699834-3f0160d4-a08b-41e0-a64d-588a034978cc.PNG)

The error is because the spacing between the notch side is less than the specified distance. This can be fixed by selecting any one side of the notch by pressing the A key for selecting the area and stretching it away from the other side. This fixed the error as shown below:
![Notch error fixed](https://user-images.githubusercontent.com/109404741/195700181-d70c770b-1bdc-4dd8-a1b6-108cda563aac.PNG)

## Via rules

Let us load the file exercise2.mag and look at exercise 2a. Here, when we run a DRC report, we see it is a simple via size error.
![via_overlap_error](https://user-images.githubusercontent.com/109404741/195701433-a69c03b5-13f9-4091-872c-04686c0a35c0.PNG)

We can fix this easily by doing an area select and stretch operation twice. Once horizontally, and once vertically.
![via_overlap_error_fixed](https://user-images.githubusercontent.com/109404741/195701642-7cc7b2e7-7e57-4fdc-b295-b90286dd95e4.PNG)

The next error is of a minimum area of metal 1 layer as shown below:
![minimum area drc error](https://user-images.githubusercontent.com/109404741/195702203-33839a94-254a-4ffe-94dc-4124c400eaa6.PNG)

This error can be fixed by changing the dimension of the area so that the area is almost that of the specified area. This is done as follows:
![minimum area drc error_fixed](https://user-images.githubusercontent.com/109404741/195702513-866ca25d-5358-4586-b1e0-e95d715a02be.PNG)

Next, let us look at example 3b. Here we have a minimum hole area violation, though Magic does not show it as one. To se this DRC error, we need to run Magic in the full DRC mode. We can do this by clicking on the menu button DRC > DRC complete. Next we must tell Magic to update the DRC count, and then run a DRC report.
![minimum hole area_error](https://user-images.githubusercontent.com/109404741/195702879-2bf50b96-f0bf-47cf-a555-8f801082fdef.PNG)

To fix this minimum hole error we can select the hole area using the box and then type the command ```box grow c length_val```. This will increase the width and height eqaully which is equal to the length_val. Then we can delete the extra metal area. This will fix the error as follows:
![minimum hole area_error_fixed](https://user-images.githubusercontent.com/109404741/195703264-94068938-6375-4065-94d6-1e519539d91f.PNG)

## Wells and Deep Nwells

Let's look at exercise4.mag which has wells and taps, so our DRC check needs to be set at full to check for these. Let us see example 4a. We have a basic well error, since the wells do not have taps. The n-well shows an error as it is currently floating, though the "p-well" does not since this process doesn't actually consider p-wells unless they are in deep n-wells, and are instead counted as p-substrates.
![nwell_notap_error](https://user-images.githubusercontent.com/109404741/195703623-3e0f5242-b9f2-4d10-8f45-7f7f5c8d3ce7.PNG)

To fix this, we first paint a layer of n type material into the n well. The layer is called nsubstratendiff. Though this does not fix the DRC error.The n well must not be floating, so the tap should be connected to a layer of local interconnect. So let us do this by painting a layer of nsubstratencontact. While this gets rid of the n-well DRC error, it creates smaller errors like overlap and surround.
![nwell_tap_contact_error](https://user-images.githubusercontent.com/109404741/195703775-1d9fe89a-d9db-4dc8-906f-41b9303920c2.PNG)

Let us adjust the layers using what we have learnt till now by growing, stretching and adding in local interconnect, and we get no DRC errors.
![nwell_tap_contact_error_fixed](https://user-images.githubusercontent.com/109404741/195703910-3e1a97d7-4e6d-4d5d-a1cd-4bee36414c0c.PNG)

## Angle And Overlap Rule
If we recall, Magic has a grid set up that is based on the manufacturing grid provided. The manufacturing grid for this process is 0.005um x 0.005um. Magic scales up the grid by a factor of 2, so the smallest box possible should be 0.01um by 0.01um. To make the box any smaller, we can use snap internal then make the box to the size of the manufacturers grid. We could also scale down Magic's internal grid with scalegrid 1 2, but it is prohibited.

Similarly, if we create a tringle that is an odd number width, and overlap it with another odd width triangle, magic will try to legalise the overlap vertex as follows.
![Auto Legalization](https://user-images.githubusercontent.com/109404741/195704826-d205998d-8db5-40eb-a1bb-050d1f7824b8.PNG)

The next DRC error is due to a local interconnect having a corner cut. Local interconnects are not allowed to have corner cuts.
![local interconnect drc error](https://user-images.githubusercontent.com/109404741/195705112-45fa6759-0038-4573-a21d-9910c9979431.PNG)
Tp fix this error we can simply draw a box covering the cut area and fill it with Local interconnect material. This will fix the error as follows:
![local interconnect drc error_fixed](https://user-images.githubusercontent.com/109404741/195705300-dd6d9498-a3b1-4ab0-a605-b2247cd4159e.PNG)

we have another angle error. The shapes seems to be 45 degree angled, but by selecting it and querying the box, we see it is actual 201x200 units on the grid, leading to an angle just smaller than 45 degrees.
![metal1_drc_error](https://user-images.githubusercontent.com/109404741/195705448-cb368a0a-5d03-4751-8ba9-099a6086df7f.PNG)
 Since, the error is due to the angle of cut being less than 45 degrees we can check for the measurements of the height and base width of the triangle formed by it as follows:
![metal1_drc_error_dimensions](https://user-images.githubusercontent.com/109404741/195705637-29c1984e-bb79-4152-a1f0-1278f2b36a7e.PNG)
We can fix this error if we make the dimensions of the height and base width equal and then paint the south west or lower diagonal area of the box with metal1 as follows:
![metal1_drc_error_fixed](https://user-images.githubusercontent.com/109404741/195705835-d6cba793-53a7-411c-a60a-021ef081e806.PNG)



















 








